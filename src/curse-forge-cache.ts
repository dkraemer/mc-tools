import * as crypto from 'crypto';
import * as fs from 'fs-extra';
import * as cfApi from 'mc-curseforge-api';
import { writeFile } from 'fs/promises';
import { FileManifest } from './curse-manifest';

export interface ProgressCallback {
  (addonName: string, current: number, last: number): void
}

export enum CacheErrorName {
  noOverwrite = 'NO_OVERWRITE',
  noMetadata = 'NO_METADATA',
  fileNotFound = 'FILE_NOT_FOUND',
  invalid = 'INVALID'
}

export class CacheError implements Error {
  name: string;
  message: string;
  stack?: string | undefined;

  public constructor(message: string, name: CacheErrorName) {
    this.message = message;
    this.name = name;
  }
}

export class CurseForgeCache {
  private readonly WARNING = 'DO NOT EDIT THIS FILE!';
  private lastUpdated: string | undefined;
  private readonly mods: Mod[];
  private readonly modFiles: ModFile[];
  private digest: string | undefined;

  public static async generate(
    cachePath: string,
    addonFiles: FileManifest[],
    overwrite?: boolean,
    progress?: ProgressCallback): Promise<CurseForgeCache> {

    if (fs.existsSync(cachePath) && !overwrite) {
      throw new CacheError(
        `${cachePath} exists and overwrite is set to false`,
        CacheErrorName.noOverwrite);
    }

    const cache = new CurseForgeCache();

    const last = addonFiles.length;

    let i = 1;
    for (const addon of addonFiles) {
      const modId = addon.projectID;

      const mod = await cfApi.getMod(modId);
      cache.mods.push(mod);

      const modFile = (await mod.getFiles()).find(e => e.id === addon.fileID);
      if (!modFile) {
        throw new CacheError(
          `Unable to download file metadata for projectID:'${addon.projectID}' fileID:'${addon.fileID}'`,
          CacheErrorName.noMetadata);
      }
      cache.modFiles.push(modFile);

      if (progress) {
        progress(mod.name, i, last);
      }

      i++;
    }

    cache.lastUpdated = new Date(Date.now()).toISOString();
    cache.updateDigest();

    await writeFile(cachePath, JSON.stringify(cache, null, 2), { flag: overwrite ? 'w' : 'wx' });

    return cache;
  }

  public static async load(cachePath: string): Promise<CurseForgeCache> {
    if (!fs.existsSync(cachePath)) {
      throw new CacheError(
        `File not found: ${cachePath}`,
        CacheErrorName.fileNotFound);
    }

    const cacheImport = await import(cachePath) as CurseForgeCache;
    if (!CurseForgeCache.validate(cacheImport)) {
      throw new CacheError(
        `Validation of cache file failed: ${cachePath}`,
        CacheErrorName.invalid);
    }

    const cacheObject = new CurseForgeCache();
    cacheObject.lastUpdated = cacheImport.lastUpdated;
    cacheObject.mods.push(...cacheImport.mods);
    cacheObject.modFiles.push(...cacheImport.modFiles);
    cacheObject.updateDigest();

    return cacheObject;
  }

  private static getDigest(cache: CurseForgeCache): string {
    const localHash = crypto.createHash('sha256');
    const modsJson = JSON.stringify(cache.mods);
    const modFilesJson = JSON.stringify(cache.modFiles);
    return localHash.update(cache.WARNING + cache.lastUpdated + modsJson + modFilesJson).digest('hex');
  }

  private static validate(cache: CurseForgeCache): boolean {
    return (cache !== undefined)
      && (typeof cache.lastUpdated === 'string')
      && (typeof Date.parse(cache.lastUpdated) === 'number')
      && (cache.mods instanceof Array)
      && (cache.modFiles instanceof Array)
      && (typeof cache.digest === 'string')
      && (CurseForgeCache.getDigest(cache) === cache.digest);
  }

  public constructor() {
    this.mods = [];
    this.modFiles = [];
  }

  public getLastUpdated(): string | undefined {
    return this.lastUpdated;
  }

  public getMods(): readonly Mod[] {
    return this.mods;
  }

  public getModFiles(): readonly ModFile[] {
    return this.modFiles;
  }

  public getDigest(): string | undefined {
    return this.digest;
  }

  private updateDigest(): void {
    this.digest = CurseForgeCache.getDigest(this);
  }
}
